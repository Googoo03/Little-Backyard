// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture2D<float4> SimplexTex;

RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<int> dualGrid;
RWStructuredBuffer<uint> indices;
float3 global;
float3 dimensions;
int LOD_Level = 0;
float CELL_SIZE;
bool block_voxel = false;

groupshared int vertIndex = 0;


float adapt(float x0, float x1){    return x1 == x0 ? 0 : (-x0) / (x1 - x0);}

float3 Grid(float3 pos, int elevation) { return pos;}

float function(int3 pos, float elevation)
{

    /*float3 step = float3(1f / (dimensions.x), 1f / (dimensions.y), 1f / (dimensions.z));
    step *= (1f / (1 << LOD_Level));
    step *= CELL_SIZE;
*/
    int index = (int) (pos.x + dimensions.x * (pos.y + dimensions.y * pos.z));

    if (elevation >= (float)dimensions.y - 1)
    {
        return -1;
    }
    if (elevation <= 1)
    {
        return 1;
    }
    int Ground = dimensions.y / 2;
    int amplitude = 3;

    float value = /*(1.0 - /*abs(SimplexTex[pos.xy].r)) * amplitude +*/Ground - elevation; // + SimplexTex[pos.xy].r;

    return value;
}

void Find_Best_Vertex(int x, int y, int z)
{


            //determines the "step" between vertices to cover 1 unit total
    float3 step = float3(1.0 / (dimensions.x), 1.0 / (dimensions.y), 1.0 / (dimensions.z));
    step *= (1.0 / (1 << LOD_Level));
    step *= CELL_SIZE;

            //sets the offset of the grid by a power of two based on the LOD level
    float3 offset = float3(-1,-1,-1) * (1.0 / (1 << (LOD_Level + 1))) * (CELL_SIZE);

            //We have 8 vertices, and need to store them for later use
    float3 pos = offset + float3(x * step.x, y * step.y, z * step.z);


    float vertValues[8];
    float3 vertPos[8];
    int i = 0;
    for (; i < 8; ++i)
    {
        vertPos[i] = Grid(pos + float3(step.x * ((i >> 2) & 0x01), step.y * ((i >> 1) & 0x01), step.z * (i & 0x01)), y + ((i & 2) == 2 ? 1 : 0));
        
        //beware the function calls for an int3 but vertpos is a float
        vertValues[i] = function(global + vertPos[i], y + ((i & 2) == 2 ? 1 : 0));
    }
            //calculate the adapt of only the edges that cross, rather than the whole thing
            //calculate the positions of the edges itself


    //set sign change if any edge is crossed
    int signChange = false;
    signChange |= (vertValues[0] > 0) != (vertValues[4] > 0);
    signChange |= (vertValues[0] > 0) != (vertValues[1] > 0);
    signChange |= (vertValues[5] > 0) != (vertValues[1] > 0);
    signChange |= (vertValues[5] > 0) != (vertValues[4] > 0);
    signChange |= (vertValues[4] > 0) != (vertValues[6] > 0);
    signChange |= (vertValues[1] > 0) != (vertValues[3] > 0);
    signChange |= (vertValues[0] > 0) != (vertValues[2] > 0);
    signChange |= (vertValues[5] > 0) != (vertValues[7] > 0);
    signChange |= (vertValues[6] > 0) != (vertValues[7] > 0);
    signChange |= (vertValues[3] > 0) != (vertValues[7] > 0);
    signChange |= (vertValues[2] > 0) != (vertValues[3] > 0);
    signChange |= (vertValues[2] > 0) != (vertValues[6] > 0);

    if (!signChange)
        return;
    
    
    float3 avg = float3(0, 0, 0);
    int count = 0;

            //X EDGES NEW 
    for (i = 0; i < 4; ++i)
    {
        float a = vertValues[i];
        float b = vertValues[i | 0x04];
        if (a > 0 != b > 0)
        {
            avg += vertPos[i] + adapt(a, b) * (vertPos[i | 0x04] - vertPos[i]);
            count++;
        }
    }

            //Y EDGES
    int yindices[] = {0, 1, 4, 5};
    
    for (i = 0; i < 4; ++i)
    {
        int j = yindices[i];
        float a = vertValues[j];
        float b = vertValues[j | 0x02];
        if (a > 0 != b > 0)
        {
            avg += vertPos[j] + adapt(a, b) * (vertPos[j | 0x02] - vertPos[j]);
            count++;
        }
    }

            //Z EDGES
    for (i = 0; i < 4; ++i)
    {
        float a = vertValues[(i << 1)];
        float b = vertValues[(i << 1) | 0x01];
        if (a > 0 != b > 0)
        {
            avg += vertPos[i << 1] + adapt(a, b) * (vertPos[(i << 1) | 0x01] - vertPos[i << 1]);
            count++;
        }
    }

    avg /= count > 1 ? count : 1;

            //figure out what edge was crossed (axis)

            //Assign the sign of the edge according to how the flip occurs

            //The normals shouldn't have x,y,z as their parameters, but should instead reflect
            //the positions of the intermediate point on the edge.

    bool xCross = vertValues[6] > 0 != vertValues[7] > 0;
    bool yCross = vertValues[5] > 0 != vertValues[7] > 0;
    bool zCross = vertValues[3] > 0 != vertValues[7] > 0;
    uint newedge = 0;
    
    
    if (xCross)
    {
        newedge |= /*0x00000020;*/ 1 << 5;
        newedge |= ((vertValues[6] > 0) && !(vertValues[7] > 0)) << 4; //? 0x00000010 : 0x00000000;
        //_newedges[0].crossed = true;
        //_newedges[0].sign = (vertValues[6] > 0) && !(vertValues[7] > 0); // = new Edge(true, (vertValues[6] > 0) && !(vertValues[7] > 0)); //need to change intersection and normal later if we want interpolation
    }
    if (yCross)
    {
        //_newedges[1].crossed = true;
        //_newedges[1].sign = !(vertValues[5] > 0) && (vertValues[7] > 0);
        
        newedge |= 1 << 3;
        newedge |= (!(vertValues[5] > 0) && (vertValues[7] > 0)) << 2;
    }
    if (zCross)
    {
        //_newedges[2].crossed = true;
        //_newedges[2].sign = (vertValues[3] > 0) && !(vertValues[7] > 0);
        
        newedge |= 1 << 1;
        newedge |= ((vertValues[3] > 0) && !(vertValues[7] > 0));

    }

    float3 vertex = block_voxel ? vertPos[0] : avg;

    uint index = (uint) (x + dimensions.x * (y + dimensions.y * z));
    

    uint dualgrid_representation = 0x0;
    dualgrid_representation |= newedge;
    
    dualgrid_representation |= (index << 6);
    
    
    //INSTEAD OF INDEX, USE HOW MANY VERTICES THERE ARE SO FAR.
    //HOW TO DO SO? USE A COMPARE-ADD-SWAP OPERATOR TO INCREMENT
    //THE AMOUNT OF VERTICES BETWEEN THREADS.
    
    //THEN, USE ANOTHER COMPARE-ADD-SWAP (OR A LOCK) TO SET DUALGRID
    //TO THE CORRECT VERTEX INDEX
    int oldIndex = vertIndex;
    InterlockedAdd(vertIndex,1,oldIndex);
    
    dualGrid[index] |= (newedge | (oldIndex << 6));
    vertexBuffer[index] = vertex; //vertex; //should this be index?

}

void CreateQuads(int x, int y, int z)
{
    
    int index = (int) (x + dimensions.x * (y + dimensions.y * z));
    uint dualGrid_index = dualGrid[index];

    if ((dualGrid_index & 0x20) == 0x20) //if edge[0].crossed
        {
                //Make a quad from neighboring x cells
        if ((dualGrid_index & 0x10) == 0x10) //if edge[0].sign
        {
            
        //IF BOTH VERTS AND DUALGRID ARE INDEXED THE SAME THEN JUST REFERENCE VERTS
            
            
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 1] = dualGrid[(x + 1) + dimensions.x * (y + dimensions.y * z)] >> 6;
            indices[4 * index + 2] = dualGrid[(x + 1) + dimensions.x * ((y + 1) + dimensions.y * z)] >> 6;
            indices[4 * index + 3] = dualGrid[x + dimensions.x * ((y + 1) + dimensions.y * z)] >> 6;
        }
        else
        {
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 1] = dualGrid[(x + dimensions.x * ((y + 1) + dimensions.y * z))] >> 6;
            indices[4 * index + 2] = dualGrid[((x + 1) + dimensions.x * ((y + 1) + dimensions.y * z))] >> 6;
            indices[4 * index + 3] = dualGrid[((x + 1) + dimensions.x * (y + dimensions.y * z))] >> 6;
            
        }
    }
    if ((dualGrid_index & 0x8) == 0x8)
    {
        //indices[index] = 512;
            //Make a quad from neighboring y cells
        if ((dualGrid_index & 0x4) == 0x4)
        {
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 1] = dualGrid[(x + 1) + dimensions.x * (y + dimensions.y * z)] >> 6;
            indices[4 * index + 2] = dualGrid[(x + 1) + dimensions.x * (y + dimensions.y * (z + 1))] >> 6;
            indices[4 * index + 3] = dualGrid[x + dimensions.x * (y + dimensions.y * (z + 1))] >> 6;
        }
        else
        {
                
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 3] = (dualGrid[(x + 1) + dimensions.x * (y + dimensions.y * z)] >> 6);
            indices[4 * index + 2] = (dualGrid[(x + 1) + dimensions.x * (y + dimensions.y * (z + 1))] >> 6);
            indices[4 * index + 1] = (dualGrid[x + dimensions.x * (y + dimensions.y * (z + 1))] >> 6);
                
        }
    }
    if ((dualGrid_index & 0x2) == 0x2)
    {
                //Make a quad from neighboring z cells
        if ((dualGrid_index & 0x1) == 0x1)
        {
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 1] = dualGrid[x + dimensions.x * ((y + 1) + dimensions.y * z)] >> 6;
            indices[4 * index + 2] = dualGrid[x + dimensions.x * ((y + 1) + dimensions.y * (z + 1))] >> 6;
            indices[4 * index + 3] = dualGrid[x + dimensions.x * (y + dimensions.y * (z + 1))] >> 6;
        }
        else
        {
            indices[4 * index] = dualGrid[index] >> 6;
            indices[4 * index + 1] = dualGrid[x + dimensions.x * (y + dimensions.y * (z + 1))] >> 6;
            indices[4 * index + 2] = dualGrid[x + dimensions.x * ((y + 1) + dimensions.y * (z + 1))] >> 6;
            indices[4 * index + 3] = dualGrid[x + dimensions.x * ((y + 1) + dimensions.y * z)] >> 6;
        }
    }
}

[numthreads(32,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupThreadID)
{
    // TODO: insert actual code here!
    
    //start index
    int3 s_index = int3(ceil(dimensions.x / 32.0) * gid.x, 0, 0);
    int3 e_index = int3((ceil(dimensions.x / 32.0) * (gid.x + 1)) - 1, dimensions.y, dimensions.z);
    //Compute starting and ending indices here
    
    //Compute vertex positions
    for (int x = s_index.x; x < e_index.x; ++x)
    {
        for (int y = s_index.y; y < e_index.y; ++y)
        {
            for (int z = s_index.z; z < e_index.z; ++z)
            {
                Find_Best_Vertex(x, y, z);
            }
        }
    }
    //Barrier here
    GroupMemoryBarrierWithGroupSync();
    
    //DO CONDENSE VERTICES BEFORE INDICES. SINCE IN SERIAL IMPLEMENTATION
    //THE DUALGRID REFERENCES THE VERTICES ARRAY, WHICH IS A CONDENSED ARRAY.
    
    //
    
    //Compute quad indices
    /*for (x = s_index.x; x < e_index.x; ++x)
    {
        for (int y = s_index.y; y < e_index.y; ++y)
        {
            for (int z = s_index.z; z < e_index.z; ++z)
            {
                //compute quad
                CreateQuads(x, y, z);

            }
        }
    }*/
    
    //the indices array is assumed to be 4*length(vertexBuffer)
    
    //both arrays will be condensed in the cpu
    
    //Since memory is shared, no need to transform the vertex indices
}
