using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UIElements;


namespace worley_3d {
    public class Worley3D
    {
        private Vector3 origin;
        private List<Vector3> points;
        private int size;
        private float pointResolution;
        private float persistence;
        private float amplitude;
        private int octaves;
        private float lacunarity;

        //CONSTRUCTOR TO INITIALIZE VALUES
        public Worley3D(ref List<Vector3> worleyPoints, Vector3 _origin,int resolution,float pointRes,float persist,int octave,float lacun,float amp) {
            points = new List<Vector3>();
            origin = _origin;
            size = resolution;
            pointResolution = pointRes;
            persistence = persist;
            octaves = octave;
            lacunarity = lacun;
            amplitude = amp;
        }

        private void generateWorleyPoints(Vector3 index)
        {
            //Vector3 point = new Vector3(UnityEngine.Random.Range(-100, 100), UnityEngine.Random.Range(-100, 100), UnityEngine.Random.Range(-100, 100));
            Vector3 point = origin + new Vector3(index.x / size - 0.5f, index.y / size - 0.5f, index.z / size - 0.5f);

            point += (Vector3.one * (1.0f / size))+(new Vector3(UnityEngine.Random.Range(-0.5f,0.5f), UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-0.5f, 0.5f))/(size/pointResolution));

            float unitSize = pointResolution/size;
            //point += Vector3.one * 0.5f * unitSize;//new Vector3(1f / size * 0.5f, 1f / size * 0.5f, 1f / size * 0.5f);

            points.Add(point);
        }

        private float FindClosestPoint(Vector3 index)
        {

            float closestDistance = float.MaxValue;
            float distance;
            //Vector3 point = origin + new Vector3(index.x / size - 0.5f, index.y / size - 0.5f, index.z / size - 0.5f);
            Vector3 point = origin + (index / size) - (Vector3.one*(0.5f));


            float pointCoordScalar = (int)size / (int)pointResolution;
            int maxpointAlongAxis = (int)Mathf.Ceil(pointResolution);//(int)(size / (int)pointResolution);

            //find current box
            Vector3 boxIndex = new Vector3((int)index.x / pointCoordScalar, (int)index.y / pointCoordScalar, (int)index.z / pointCoordScalar);

            for (int i = -1; i < 2; ++i) {
                for (int j = -1; j < 2; ++j)
                {
                    for (int k = -1; k < 2; ++k)
                    {

                        //Apply transformation
                        int x = (int)boxIndex.x + i;
                        int y = (int)boxIndex.y + j;
                        int z = (int)boxIndex.z + k;

                        //Convert back to 1D coordinates
                        x = (x % maxpointAlongAxis + maxpointAlongAxis) % maxpointAlongAxis;
                        y = (y % maxpointAlongAxis + maxpointAlongAxis) % maxpointAlongAxis;
                        z = (z % maxpointAlongAxis + maxpointAlongAxis) % maxpointAlongAxis;

                        int currentIndex = (x + maxpointAlongAxis*(y+(maxpointAlongAxis*z) ));

                        float dx = Math.Abs(points[currentIndex].x - point.x);
                        float dy = Math.Abs(points[currentIndex].y - point.y);
                        float dz = Math.Abs(points[currentIndex].z - point.z);

                        // Apply wrapping for each dimension
                        // CHANGE THE 1 TO AN APPROPRIATE DISTANCE FOR ALL OCTAVES AND FREQUENCIES
                        dx = Math.Min(dx, 1 -  dx);
                        dy = Math.Min(dy, 1 -  dy);
                        dz = Math.Min(dz, 1 -  dz);

                        distance = Mathf.Sqrt((dx * dx) + (dy * dy) + (dz * dz));
                        if (distance < closestDistance) closestDistance = distance;

                    }
                }
            }
            return closestDistance;
        }


        [MenuItem("CreateExamples/3DTexture")]
        public void CreateTexture3D()
        {
            //takes in the worley points generated by the planet script.

            //worley points are in world position
            //amplitude = 0.5f;
            


            // Configure the texture
            //int size = 32;
            TextureFormat format = TextureFormat.RGBAFloat;
            TextureWrapMode wrapMode = TextureWrapMode.Repeat;

            // Create the texture and apply the configuration
            Texture3D texture = new Texture3D(size, size, size, format, false);
            texture.wrapMode = wrapMode;

            // Create a 3-dimensional array to store color data
            Color[] colors = new Color[size * size * size];

            for (int i = 0; i < octaves; ++i)
            {
                points = new List<Vector3>();
                //create array of worley points proportional to the size of the area
                for (int z = 0; z < pointResolution; z++)
                {
                    int zOffset = z * (size / 8) * (size / 8);
                    for (int y = 0; y < pointResolution; y++)
                    {
                        int yOffset = y * (size / 8);
                        for (int x = 0; x < pointResolution; x++)
                        {
                            //This matches the position of each point to the image coords. Figures out how many indices to skip
                            float pointCoordScalar = size / pointResolution;
                            Vector3 index = new Vector3(x, y, z) * pointCoordScalar;
                            generateWorleyPoints(index);
                        }
                    }
                }

                int R = i==0 ? 1 : 0;
                int G = i == 1 ? 1 : 0;
                int B = i == 2 ? 1 : 0;
                // Populate the array so that the x, y, and z values of the texture will map to red, blue, and green colors
                float inverseResolution = 1.0f / (size - 1.0f);
                for (int z = 0; z < size; z++)
                {
                    int zOffset = z * size * size;
                    for (int y = 0; y < size; y++)
                    {
                        int yOffset = y * size;
                        for (int x = 0; x < size; x++)
                        {
                            Vector3 index = new Vector3(x, y, z);
                            float scalar = FindClosestPoint(index);
                            if (i == 0) colors[x + yOffset + zOffset] = new Color(1, 1, 1, 1);

                            colors[x + yOffset + zOffset] -= (new Color(R, G, B, 1) * scalar*amplitude);
                        }
                    }
                }
                pointResolution *= lacunarity ;
                amplitude *= persistence;
            }

            // Copy the color values to the texture
            texture.SetPixels(colors);

            // Apply the changes to the texture and upload the updated texture to the GPU
            texture.Apply();

            // Save the texture to your Unity Project
            AssetDatabase.CreateAsset(texture, "Assets/Example3DWorleyTexture.asset");
        }

      
    }
}
